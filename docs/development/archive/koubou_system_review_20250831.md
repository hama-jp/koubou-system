
# 🏭 工房システム (Koubou System) コードレビュー

## 1. 総評

工房システムは、LLM（大規模言語モデル）を活用したタスク処理自動化のための、非常によく設計された堅牢なシステムです。特に、動的なワーカー管理によるスケーラビリティ、インテリジェントなタスク処理、そしてセキュリティへの配慮が印象的です。

全体として、概念実証（PoC）の段階を大きく超え、実運用を視野に入れた本格的な設計がなされています。コードはモジュール化されており、各コンポーネントが明確な責務を持っているため、メンテナンス性と拡張性に優れています。

**総合評価: A (優秀)**

--- 

## 2. アーキテクチャ評価

採用されているマイクロサービス指向のアーキテクチャは、本システムに非常に適しています。

- **MCPサーバー**: タスクの受付と管理を行う中央司令塔として機能。
- **ワーカープールマネージャー**: システムの負荷に応じてワーカーを動的に増減させる、スケーラビリティの要。
- **ローカルワーカー**: 実際のタスク（LLMコール、ファイル操作）を実行する実行部隊。
- **各種サーバー (WebSocket/GraphQL)**: リアルタイム通信や柔軟なデータ取得といった高度な要求に対応。

この設計により、各コンポーネントを独立して開発・デプロイでき、システム全体の柔軟性と耐障害性が高まっています。

--- 

## 3. コード品質と設計

### 評価ポイント

- **設定の一元管理**: `system.yaml` にシステム全体の設定が集約されており、管理が容易です。
- **動的スケーリング**: `worker_pool_manager.py` の自動スケーリングロジックは、負荷に応じてリソースを効率的に利用するための優れた実装です。
- **インテリジェントなファイル保存**: `local_worker.py` がLLMの出力からファイル名や形式を推定し、自動で保存する機能は、ユーザーの負担を大幅に軽減する画期的な機能です。
- **Git連携**: タスク実行前にコードの変更点を自動でGitにコミットする機能は、作業履歴の追跡と再現性の確保に大きく貢献します。
- **堅牢性**: ヘルスチェック、ハートビート、シグナルハンドリングによる安全なシャットダウンなど、システムの安定稼働を支える仕組みが随所に見られます。

### 改善提案

1.  **データベースアクセスの一貫性**: `mcp_server.py` の一部で、`DatabaseManager` を介さずに直接 `sqlite3` を利用している箇所が見られます。すべてのDB操作を `DatabaseManager` に集約することで、一貫性が向上し、将来的なDBの変更が容易になります。

    - **対象ファイル**: `mcp_server.py`
    - **該当箇所**: `get_completed_tasks`, `get_active_tasks` 関数

2.  **設定の外部化**: スクリプト内にハードコードされたパスや設定値が散見されます。これらを `system.yaml` に集約することで、システムの柔軟性とポータビリティが向上します。

    - **対象ファイル**: `mcp_server.py`, `local_worker.py`
    - **例**: `GEMINI_EXEC` のパス、`detect_project_root` 内のデフォルトパス

3.  **コードの重複排除**: `mcp_server.py` 内で、完了済みタスクとアクティブタスクを取得するロジックに、タスク要約を生成する同様のコードが存在します。これを共通関数に切り出すことで、コードがよりクリーンになります。

--- 

## 4. セキュリティ

セキュリティに対する意識は高く、重要な対策が実装されています。

### 評価ポイント

- **ファイル操作の制限**: `system.yaml` で許可されたディレクトリと拡張子以外へのファイルアクセスを制限する仕組みは、非常に重要かつ効果的なセキュリティ対策です。
- **ワーカー認証**: ワーカーが `worker_pool_manager` から発行されたトークンを持つことを検証する仕組みは、不正なワーカーの接続を防ぎます。
- **直接的なライブラリ利用**: `local_worker.py` が `subprocess` ではなく、`gemini-repo-cli` ライブラリを直接利用している点は、コマンドインジェクションのリスクを排除する上で非常に良い判断です。

### 改善提案

- **`shell=True` の回避**: `mcp_server.py` の `execute_task_sync` 関数内で `subprocess.run` に `shell=True` が使用されています。プロンプトの内容をサニタイズする処理がない場合、コマンドインジェクションの脆弱性となる可能性があります。コマンドと引数をリスト形式で渡すように修正することを強く推奨します。

--- 

## 5. 総括と次のステップ

工房システムは、技術的に高度でありながら、実用性も兼ね備えた素晴らしいプロジェクトです。特に、自律的なスケーリングとインテリジェントなタスク処理の組み合わせは、今後の発展が非常に楽しみです。

提案した改善点を反映させることで、システムの堅牢性と保守性はさらに向上するでしょう。今後の開発ロードマップとしては、`system.yaml` で定義されている認証機能や分散処理機能の実装が考えられます。

この度はレビューの機会をいただき、ありがとうございました。今後のプロジェクトの成功を心より応援しております。

---

## 6. 詳細レビュー: 安定性向上のための改善提案

ワーカープールマネージャーとデータベース周りの不安定性について、詳細な分析を行いました。根本的な原因は、データベースへのアクセス方法の不統一と、それに伴う競合状態（レースコンディション）にある可能性が非常に高いです。

`common/database.py` は、接続プーリング、WALモード、リトライ処理など、SQLiteをマルチプロセス環境で安定稼働させるための高度な仕組みを備えていますが、一部のコードがこの仕組みをバイパスしていることが問題を引き起こしています。

### 根本原因

1.  **データベース接続の一貫性の欠如 (最重要)**
    - **問題**: `mcp_server.py` や `worker_pool_manager.py` の一部が、`DatabaseManager` を介さずに直接 `sqlite3.connect()` を呼び出しています。
    - **影響**: これにより、`DatabaseManager` が提供する接続プール、パフォーマンスチューニング(PRAGMA)、リトライ処理、ロック管理の恩恵を受けられない「野良コネクション」が生成されます。これらのコネクションが、管理下のコネクションとデータベースファイルのロックを奪い合い、`database is locked` エラーやデッドロックを引き起こし、システム全体の不安定性を招いています。
    - **該当箇所**:
        - `mcp_server.py`: `get_completed_tasks`, `get_active_tasks`
        - `worker_pool_manager.py`: `cleanup_dead_workers`, `print_stats`
        - `local_worker.py`: `register_worker`

2.  **タスク取得処理の競合状態**
    - **問題**: ワーカーは「①保留中タスクの取得」と「②自身へのタスク割り当て」を別々のステップで行っています。
    - **影響**: 複数のワーカーがほぼ同時に同じタスクを①で取得し、②の割り当てで競合する可能性があります。これは無駄な処理を発生させ、データベースへの負荷を高めます。

### 改善策

以下の改善策を実施することで、システムの安定性は劇的に向上するはずです。

1.  **`DatabaseManager` の利用を徹底する (最優先)**
    - **対策**: プロジェクト内の**すべてのデータベースアクセス**を、`get_db_manager()` 経由で行うようにリファクタリングします。`sqlite3.connect()` の直接呼び出しをすべて排除してください。これにより、すべてのDB操作が `DatabaseManager` の堅牢な接続管理下に置かれます。

2.  **タスク取得処理をアトミックにする**
    - **対策**: `DatabaseManager` に `acquire_next_task(worker_id)` のような新しいメソッドを実装します。このメソッドは、単一のトランザクション内で以下の処理を行います。
        1. `BEGIN IMMEDIATE` で即時ロックを確保。
        2. 優先度が最も高い `pending` 状態のタスクを1件取得 (`SELECT ... FOR UPDATE` のような振る舞い)。
        3. タスクが見つかれば、`status` を `in_progress` に更新し、`worker_id` を設定。
        4. `COMMIT` でトランザクションを完了。
        5. 取得したタスク情報を返す。
    - **効果**: これにより、タスクの取得と割り当てが不可分な操作となり、レースコンディションを完全に防ぐことができます。

3.  **ワーカーのタスク完了処理を統合する**
    - **対策**: `local_worker.py` で `complete_task` と `increment_worker_stats` を個別に呼び出すのではなく、`DatabaseManager` に「タスクを完了し、ワーカー統計を更新する」という単一のメソッドを実装し、それを呼び出すように変更します。
    - **効果**: タスクの完了と統計の更新が必ずセットで行われることを保証し、データの整合性を高めます。